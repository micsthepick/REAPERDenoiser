desc:Convolution Ratio Denoiser

// loosely based off github.com/nbickford/REAPERDenoiser

// This defines a combo box that allows the user to select "Denoise Input" or
// "Record Noise Sample". The default value is 0 (Denoise Input). The maximum
// value is 1 (Record Noise Sample), and it increases in steps of 1.
slider1:0<0,1,1{Denoise Input, Record Noise Sample}>Noise Collection Mode

// This defines a slider that can be varied between 0.0 and 10.0 in steps of
// 0.001, with default value 1.0. (If slider2 is equal to 0.0, this plugin
// shouldn't really do anything to the input audio.)
slider2:1<0.0,10.0,0.001>Noise Scale

// This defines a slider that specifies the max level (in dB)
// of the noise that is recorded
slider3:-120<-120,0,0.1>Noise detect min (dB)

// This defines a slider that specifies the minimum level (in dB)
// that a noise is recorded with (useful to filter out silence)
slider4:0<-120,0,0.1>Noise detext max (dB)

// This defines a slider to mix between no noise reduction or
// any amount of noise reduction.
slider5:100<0,100,0.5>Wet/dry mix (0 = all dry, 100 = all wet)

// checkbox? to enable/disable difference monitoring
slider6:0<0,1,1{Off, On}>Difference monitoring

// Here we can label our input and output pins. This also tells REAPER how many
// channels we can handle. In this case, the plugin is stereo (a monophonic
// plugin would be simpler, but I almost always use this to denoise stereo
// audio), so we define two input and output pins.
in_pin:Noisy Audio 1
in_pin:Noisy Audio 2
out_pin:Denoised Audio 1
out_pin:Denoised Audio 2


import cookdsp.jsfx-inc

@gfx 1026 200
gfx_set(1, 0, 0);
bi = 0;
loop(min(513, SIZE/2+1),
  gfx_line(bi, 200*(1-tileBufL[bi]), bi, 199);
  bi += 1;
);
bi = 0;
loop(min(513, SIZE/2+1),
  gfx_line(bi+513, 100, bi+513, 100-100*visBuf[bi*2]);
  bi += 1;
);

@init
// function to convert decibel measurement to decimal value
function dBtoDec(value)
(
  2^(value/6);
);
// On initialization, initialize all of our variables.

function memalloc_(sz) (
    // compensate for cookdsp adding some extra space
    // (avoids problems with memory layout when using
    //    FFT/MDCT and trying to manually keep track of the layout)
    __memory_next -= 8;
    memalloc(sz);
);

function ceps_permute(buf, size)
local(i, temp)
(
  // normally swap i and i + SIZE/2, but instead
  // swap each adjacent pair, starting from 0, 2, ...
  // because the permutation is bit-reversed after fft.
  i = 0;
  loop(size/2,
    // swap Re for these two bands
    temp = buf[i];
    buf[i] = buf[i + 2];
    buf[i] = temp;
    i += 1;
    // swap Im for these two bands
    temp = buf[i];
    buf[i] = buf[i + 2];
    buf[i] = temp;
    // next band
    i += 3;
  );
);

// The FFT size will always be constant.
SIZE = 4096;
DSIZE = 2*SIZE;
invSIZE = 1/SIZE;
sqrtinvSIZE = sqrt(invSIZE);
halfSIZE = SIZE*0.5;

convBuffer = memalloc_(DSIZE);

visBuf = memalloc_(SIZE);

fftOutL = memalloc_(DSIZE);
fftOutR = memalloc_(DSIZE);

tileBufL = memalloc_(DSIZE);
tileBufR = memalloc_(DSIZE);

outLbuf = memalloc_(SIZE);
outRbuf = memalloc_(SIZE);

noiseBufferL = memalloc_(SIZE);
noiseBufferR = memalloc_(SIZE);

delBufL = memalloc_(halfSIZE);
delBufR = memalloc_(halfSIZE);

window_buf = memalloc_(halfSIZE);

// fill window_buf with a hahn window
i = 0;
loop(halfSIZE,
  0.5 + 0.5*cos(2*$pi*i/(halfSIZE-1))
);

runningSumL = memalloc_(1);
runningSumR = memalloc_(1);


// freembuf is only needed if the memory ever gets assigned to, and then can be freed.

// samplesCollected will be our position in *_history
samplesCollected = 0;

// Finally, the algorithm we use outputs modified audio SIZE samples after we
// input it. If we tell REAPER that the plugin has a delay of SIZE samples,
// REAPER can automatically compensate for this and make it appear as if there's
// no delay at all.
pdc_delay=SIZE/2; 
pdc_bot_ch=0;
pdc_top_ch=2;


@slider
// A simple function to zero out the noise buffers when switching mode to "Record Noise Sample"
// previousMode should default to 0 on first initialization, but setting it to 0 in @init will cause
// this code to get run again, and the noise profile lost even when switching to "Denoise Input"
slider1 > 0.5 ? (
  previousMode < 0.5 ? (
    memset(noiseBufferL, 0, DSIZE);
    previousMode = 1;
  )
) : previousMode = 0;
noiseLow = dBtoDec(slider3);
noiseHigh = dBtoDec(slider4);
slider6 == 0 ?
(
  wetfrac = slider5/100;
  dryfrac = (100-slider5)/100;
) : (
  dryfrac = 1;
  wetfrac = - slider5/100;
);
kSquared = sqr(slider2);


@sample

// We'll write a function to denoise a single channel, and then we'll call this
// for each of the channels.
// In this case, we'll pass in the channel number, the four input and output
// tiles, and the current sample.
// We also need to specify which variables will be local to the function (i.e.
// which variables have local instead of global scope).
// Note that channels are zero-indexed (so the left channel is channel 0, and
// the right channel is channel 1).
// Functions can return values, but this one won't return anything.
// Swapping tiles and resetting samplesCollected will be managed by the caller.
function denoiseChannel(channel tileBuf inDelBuf fftBuffer outBuf noiseBuffer runningSum samplesCollected)
(
  // Read out input audio
  sample = spl(channel); // You can also use spl0 or spl1.
  runningSum[] += sample * sample;
  
  dry = inDelBuf[samplesCollected];
  
  inDelBuf[samplesCollected] = sample;
  
  fftBuffer[samplesCollected*2] = sample*invSIZE;
  fftBuffer[samplesCollected*2+1] = 0;

  wet = outBuf[samplesCollected];

  spl(channel) = wet * wetfrac + dry * dryfrac;

  // copy from second half
  outBuf[samplesCollected] = outBuf[samplesCollected+halfSIZE];

  // Reached end of a tile?
  samplesCollected >= halfSIZE-1 ? (
    memset(fftBuffer + SIZE, 0, SIZE); 
    fft(fftBuffer, SIZE);
    
    // If slider1 is greater than 0.5 (i.e. the user selected "Record Noise
    // Sample", we store the FFT mangitudes of each of these buffers, but only when the level is correct
    runningSumVal = sqrt(2*runningSum[]*invSIZE);
    runningSum[] = 0;
    (slider1 > 0.5 && runningSumVal >= noiseLow
      && runningSumVal <= noiseHigh) ? 
    (
      // for each band, compare the norm of the noise in this frame.
      // If it is greater than what's already there for this band, then copy
      // it into the noiseBuffer
      index = 0;
      loop(SIZE,
        squareMagnitudeNew = sqr(fftBuffer[2*index]) + sqr(fftBuffer[2*index+1]);
        squareMagnitudeOld = noiseBuffer[index];
        noiseBuffer[index] = 0.25 * squareMagnitudeNew + 0.75 * squareMagnitudeOld;
        index += 1;
      );
    );

    // Apply Norbert Weiner's filtering algorithm,
    //   X(f) = Y(f) * (|Y(f)|^2)/(|Y(f)|^2 + k^2 |N(f)|^2)
    // sqr() computes the square of a number, and abs() computes the absolute
    // value of a number. We also include a factor of 1/SIZE, to normalize the
    // FFT (so that if we don't do any denoising, the input signal is equal to
    // the output signal).

    // clear ConvBuffer
    memset(convBuffer, 0, DSIZE);

    // Loop over each band, from bandIndex = 0 to SIZE - 1.
    bandIndex = 0;
    loop(SIZE,
      // Compute |Y(f)|^2 = real(Y(f))^2 + imaginary(Y(f))^2
      yNorm = sqr(fftBuffer[bandIndex]) + sqr(fftBuffer[bandIndex + 1]);
      // The same for the noise component:
      nNorm = noiseBuffer[0.5*bandIndex];
      
      attenuationFactor = yNorm / (yNorm + kSquared * nNorm);
      
      ((yNorm + nNorm)*100000000 == 0) ? attenuationFactor = 1;

      convBuffer[bandIndex] = attenuationFactor * invSIZE;
      
      tileBuf[bandIndex*0.5] = attenuationFactor;
      
      bandIndex += 2;
    );
    
    fft_permute(tileBuf, SIZE/2);
    
    ZZZ1 = convBuffer[0];
    
    bandIndex = 0;
    loop(SIZE,
      // calculate log(|H(k)|^2)/4 == log(|H(k)|)/2
      convBuffer[bandIndex] = max(-1099511627776, log(abs(convBuffer[bandIndex]))*0.5)*invSIZE;
      convBuffer[bandIndex+1] = 0;
      bandIndex += 2;
    );

    // permute so that bands are layed out in correct order
    ceps_permute(convBuffer, SIZE);
    // convert to cepstrum
    ifft(convBuffer, SIZE);

    // remove DC and nyquist, and mult +f by -1
    // f by 2 and -f by 0
    // bands 0 and 1 (indexes 0 1 2 3) represent
    // frequencies 0 and ny respectively
    //convBuffer[0] = 0;
    convBuffer[2] = 0;
    // leave them alone
    bandIndex = 4;
    // layout of cepstrum: band 0, ny
    // 
    loop(HALFSIZE-2,
      // just apply window to negative freq
      convBuffer[bandIndex] *= window_buf[bandIndex*0.25];
      // multiply positive frequency by -1 and window it
      convBuffer[bandIndex+2] *= -window_buf[bandIndex*0.25];
      // go to next frequency
      bandIndex += 4;
    );
    
    // reverse cepstrum into fft realm
    fft(convBuffer, SIZE);
    // un-permute (symmetric operation)
    ceps_permute(convBuffer, SIZE);

    ZZZ2 = convBuffer[0];
    ZZZ2i = convBuffer[1];

    // apply complex exp to reverse log from before
    bandIndex = 0;
    loop(SIZE,
      // e^(a+bj) = e*a(cos(b) + j*sin(b))
      mult = exp(convBuffer[bandIndex])*sqrtinvSIZE;
      convBuffer[bandIndex+1] = -mult * sin(convBuffer[bandIndex+1]);
      convBuffer[bandIndex]   = mult * cos(convBuffer[bandIndex+1]);
      bandIndex += 2;
    );

    // clean convBuffer
    ifft(convBuffer, SIZE);
    //ZZZ3 = convBuffer[0];
    // discard second half of the fir
    memset(convBuffer + SIZE, 0, SIZE);
    
    memcpy(visBuf, convBuffer, SIZE);

    fft(convBuffer, SIZE);
    ZZZ4 = convBuffer[0]; // expect this to be 1 when no denoising 

    // perform covolution
    convolve_c(fftBuffer, convBuffer, SIZE);

    // convert fft to real convolved signal
    ifft(fftBuffer, SIZE);
    
    // add first half of fftBuffer
    bandIndex = 0;
    loop(HALFSIZE,
      outBuf[bandIndex] += fftBuffer[bandIndex*2];
      bandIndex += 1;
    );
    // replace second half
    loop(HALFSIZE,
      outBuf[bandIndex] = fftBuffer[bandIndex*2];
      bandIndex += 1;
    );
  ); // samplesCollected >= SIZE/2-1
); // function denoiseChannel(...

// Now, call denoiseChannel for each of the channels.
denoiseChannel(0, tileBufL, delBufL, fftOutL, outLbuf, noiseBufferL, runningSumL, samplesCollected);
denoiseChannel(1, tileBufR, delBufR, fftOutR, outRbuf, noiseBufferR, runningSumR, samplesCollected);
// Go to the next sample
samplesCollected += 1;
samplesCollected %= HALFSIZE;

@serialize
// Sliders are serialized automatically, so all we have to serialize is the two
// noise buffers. JSFX's serialization works in a clever way: when reading the
// state of the plugin from a serialized version, these functions copy data into
// noiseBufferL and noiseBufferR. But when writing out the state of the plugin,
// they work the other way, copying data out of noiseBufferL and noiseBufferR.
file_mem(0, noiseBufferL, DSIZE);
